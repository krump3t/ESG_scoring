# Task 019: Authenticity Infrastructure & System-Wide Remediation — Design Specification

**Task ID**: 019-authenticity-infrastructure
**Phase**: Foundation (Infrastructure Layer)
**Status**: READY (context complete, awaiting implementation)
**Created**: 2025-10-26
**Updated**: 2025-10-26

---

## 0. Audit Integration

### 0.1 Canonical Audit Source

**Source of Truth**: `artifacts/authenticity/report.json` (generated 2025-10-26T23:12:40.467805Z)

**Audit Tool**: `scripts/qa/authenticity_audit.py` (SCA v13.8 compliant)

**Violation Summary**:
- **Total**: 149 violations
- **FATAL**: 9 (1 production, 8 test-only)
- **WARN**: 140

**Violation Types**:
1. **Unseeded Random** (1 FATAL): `apps/mcp_server/server.py:46`
2. **Nondeterministic Time** (81 WARN): datetime.now(), time.time()
3. **Network Imports** (33 WARN): Direct `requests` usage
4. **Silent Exceptions** (10 WARN): Except blocks with pass
5. **JSON vs Parquet** (16 WARN): Data artifacts using JSON
6. **Eval/Exec** (6 FATAL): All in test files (audit detector + tests)
7. **Workspace Escape** (2 FATAL): All in test files (security tests)

### 0.2 Remediation Contract

**Target State**:
- Status: "ok" (0 FATAL, ≤5 WARN with documented exemptions)
- Determinism: 10 runs with SEED=42 produce identical SHA256 hashes
- Network Isolation: Zero live HTTP calls in test suite
- Production Code: Zero placeholders, zero silent exceptions in CP modules

**Exemptions** (5 total, documented in `.sca/exemptions.json`):
1. Test files using to_json() for fixtures (3 violations)
2. Audit detector meta-code (2 violations)

---

## 1. Data Strategy

### 1.1 Input Data

**Primary Data**: Authenticity Audit Report
- Location: `artifacts/authenticity/report.json`
- Size: ~57 KB
- Format: JSON with violation records
- SHA256: (to be computed and stored in data_sources.json)
- Provenance: Generated by SCA authenticity audit on 2025-10-26

**Secondary Data**: Existing codebase with violations
- 149 files affected across agents/, apps/, libs/, tests/, scripts/
- Violation locations: Exact file:line mappings in audit report

### 1.2 Data Splits

**Training/Test Split**: N/A (not ML task)

**Phase-by-Phase Rollout**:
1. **Phase 1**: Single FATAL violation (`apps/mcp_server/server.py:46`)
2. **Phase 2**: Top 20 high-impact time violations (crawlers, pipeline, storage)
3. **Phase 2b**: Remaining 61 time violations (scripts, evaluation, less critical)
4. **Phase 3**: All 33 network import violations
5. **Phase 4**: All 10 silent exception violations
6. **Phase 5**: All 16 JSON vs Parquet violations

### 1.3 Data Normalization & Leakage Guards

**Normalization**: N/A (code remediation, not data processing)

**Leakage Guards**:
- **Test Isolation**: Each infrastructure module (clock.py, determinism.py, http_client.py) tested in isolation with fixed seeds
- **No Cross-Phase Dependencies**: Phase N does not depend on Phase N+1 implementation
- **Deterministic Fixtures**: All test fixtures pre-generated, version-controlled
- **Environment Isolation**: SEED, FIXED_TIME set explicitly in tests (never inherit from environment)

---

## 2. Architecture & Implementation Plan

### 2.1 Three-Layer Architecture

```
┌─────────────────────────────────────────────────────┐
│         Application Layer (agents/, apps/)          │
│   - Uses Clock, HTTPClient, get_seeded_random()    │
│   - Zero direct datetime.now() / requests calls    │
└────────────────┬────────────────────────────────────┘
                 │ Dependency Injection
┌────────────────▼────────────────────────────────────┐
│      Infrastructure Layer (libs/utils/)             │
│   - clock.py: Clock abstraction                     │
│   - determinism.py: Seeded RNG factory              │
│   - http_client.py: HTTPClient ABC + implementations│
└────────────────┬────────────────────────────────────┘
                 │ Configuration
┌────────────────▼────────────────────────────────────┐
│       Configuration Layer (.sca/, env vars)         │
│   - SEED=42 (PYTHONHASHSEED)                        │
│   - FIXED_TIME=<timestamp> (for determinism)        │
│   - exemptions.json (violation whitelist)           │
└─────────────────────────────────────────────────────┘
```

### 2.2 Phase-by-Phase Implementation

#### **Phase 1: FATAL Remediation** (2 hours, Day 1)

**Scope**: Fix unseeded random in `apps/mcp_server/server.py:46`

**Implementation**:
1. Create `libs/utils/determinism.py`:
   ```python
   """Deterministic randomness utilities for SCA compliance."""
   import os
   import random
   from typing import Optional

   def get_seeded_random(seed: Optional[int] = None) -> random.Random:
       """Get a seeded Random instance for deterministic behavior.

       Args:
           seed: Explicit seed (defaults to SEED env var or 42)

       Returns:
           Seeded Random instance
       """
       if seed is None:
           seed = int(os.getenv("SEED", "42"))
       rng = random.Random(seed)
       return rng
   ```

2. Update `apps/mcp_server/server.py:46`:
   ```python
   # Before
   import random
   stage = random.randint(1, 3)

   # After
   from libs.utils.determinism import get_seeded_random
   rng = get_seeded_random()
   stage = rng.randint(1, 3)
   ```

3. Add test `tests/utils/test_determinism.py`:
   - Test: Same seed → same sequence
   - Test: Different seeds → different sequences
   - Test: SEED env var respected

**Acceptance Criteria**:
- ✅ FATAL violation count: 1 → 0
- ✅ Test passes with SEED=42
- ✅ Determinism: 10 runs produce identical `stage` values

---

#### **Phase 2: Clock Abstraction Layer** (16 hours, Days 2-5)

**Scope**: Implement Clock abstraction, rollout to 81 time violations

**Implementation**:

1. **Create `libs/utils/clock.py`** (~150 LOC):
   ```python
   """Deterministic clock abstraction for SCA compliance."""
   import os
   import time
   from datetime import datetime
   from typing import Optional

   class Clock:
       """Injectable clock for deterministic time operations."""

       def __init__(self, fixed_time: Optional[float] = None):
           """Initialize clock with optional fixed time.

           Args:
               fixed_time: Unix timestamp (or from FIXED_TIME env var)

           Raises:
               ValueError: If fixed_time is negative
           """
           if fixed_time is None:
               fixed_time = float(os.getenv("FIXED_TIME", "0"))
           if fixed_time < 0:
               raise ValueError(f"fixed_time must be non-negative, got {fixed_time}")
           self._fixed_time = fixed_time
           self._use_fixed = self._fixed_time > 0

       def now(self) -> datetime:
           """Return current datetime (or fixed time if set)."""
           if self._use_fixed:
               return datetime.fromtimestamp(self._fixed_time)
           return datetime.now()

       def time(self) -> float:
           """Return current Unix timestamp (or fixed time if set)."""
           if self._use_fixed:
               return self._fixed_time
           return time.time()

   # Global clock instance (injectable for testing)
   _clock = Clock()

   def get_clock() -> Clock:
       """Get the global clock instance."""
       return _clock

   def set_clock(clock: Clock) -> None:
       """Set the global clock instance (for testing)."""
       global _clock
       _clock = clock
   ```

2. **Add pytest fixture in `conftest.py`**:
   ```python
   @pytest.fixture(autouse=True)
   def deterministic_clock():
       """Auto-inject deterministic clock for all tests."""
       from libs.utils.clock import set_clock, Clock
       set_clock(Clock(fixed_time=1609459200.0))  # 2021-01-01 00:00:00 UTC
       yield
       set_clock(Clock())  # Reset to real clock
   ```

3. **Rollout Strategy** (Gradual, top 20 high-impact files first):

   **Week 1: High-Impact Files** (Days 2-3, 8 hours)
   - `agents/crawler/data_providers/*.py` (7 files, 14 violations)
   - `libs/storage/astradb_*.py` (2 files, 6 violations)
   - `apps/pipeline_orchestrator.py` (1 file, 8 violations)

   **Week 1: Remaining Files** (Days 4-5, 8 hours)
   - `apps/ingestion/*.py` (3 files, 7 violations)
   - `scripts/*.py` (10 files, 20 violations)
   - `tests/*.py` (test infrastructure, 6 violations)

   **Pattern**:
   ```python
   # Before
   from datetime import datetime
   timestamp = datetime.now()

   # After
   from libs.utils.clock import get_clock
   timestamp = get_clock().now()
   ```

**Acceptance Criteria**:
- ✅ All 81 time violations remediated
- ✅ Tests pass with FIXED_TIME=1609459200
- ✅ Differential test: Outputs differ only in timestamps when FIXED_TIME unset

---

#### **Phase 3: HTTP Client Abstraction** (12 hours, Days 6-10)

**Scope**: Implement HTTPClient interface, rollout to 33 network violations

**Implementation**:

1. **Create `libs/utils/http_client.py`** (~200 LOC):
   ```python
   """HTTP client abstraction for testability & caching."""
   from abc import ABC, abstractmethod
   from typing import Any, Dict, Optional
   import requests

   class HTTPClient(ABC):
       """Abstract HTTP client interface."""

       @abstractmethod
       def get(self, url: str, **kwargs) -> requests.Response:
           """Perform GET request."""
           pass

       @abstractmethod
       def post(self, url: str, **kwargs) -> requests.Response:
           """Perform POST request."""
           pass

   class RealHTTPClient(HTTPClient):
       """Production HTTP client using requests library."""

       def get(self, url: str, **kwargs) -> requests.Response:
           return requests.get(url, **kwargs)

       def post(self, url: str, **kwargs) -> requests.Response:
           return requests.post(url, **kwargs)

   class MockHTTPClient(HTTPClient):
       """Mock HTTP client for testing (fixture-based)."""

       def __init__(self, fixtures: Dict[str, Any]):
           """Initialize with response fixtures.

           Args:
               fixtures: Dict mapping URL patterns to response objects
           """
           self.fixtures = fixtures

       def get(self, url: str, **kwargs) -> Any:
           for pattern, response in self.fixtures.items():
               if pattern in url:
                   return response
           raise ValueError(f"No fixture for URL: {url}")

       def post(self, url: str, **kwargs) -> Any:
           return self.get(url, **kwargs)  # Reuse GET logic
   ```

2. **Create fixtures** in `fixtures/http_responses/`:
   - `cdp_provider_response.json`
   - `gri_provider_response.json`
   - `sec_edgar_response.json`
   - (Generated once from live API captures)

3. **Rollout to data providers** (Days 6-8, 8 hours):
   - Update `agents/crawler/data_providers/*.py` (6 files)
   - Inject HTTPClient in `__init__(self, http_client: Optional[HTTPClient] = None)`
   - Default to `RealHTTPClient()` if not provided

   **Pattern**:
   ```python
   # Before
   import requests
   response = requests.get(url)

   # After
   from libs.utils.http_client import HTTPClient, RealHTTPClient

   class CDPProvider:
       def __init__(self, http_client: Optional[HTTPClient] = None):
           self.http = http_client or RealHTTPClient()

       def fetch_data(self, url: str):
           response = self.http.get(url)
   ```

4. **Rollout to tests** (Days 9-10, 4 hours):
   - Update all test files using `MockHTTPClient` with fixtures
   - Verify zero live network calls: `pytest --tb=short 2>&1 | grep -i "connection"`

**Acceptance Criteria**:
- ✅ All 33 network violations remediated
- ✅ Test suite: Zero live HTTP calls (all use MockHTTPClient)
- ✅ Fixtures cover all test scenarios

---

#### **Phase 4: Exception Handling Audit** (4 hours, Days 11-12)

**Scope**: Replace 10 silent exception handlers with explicit logging/re-raise

**Implementation**:

1. **Pattern for remediation**:
   ```python
   # Before (silent, BLOCKED)
   try:
       risky_operation()
   except Exception:
       pass

   # After (explicit, COMPLIANT)
   import logging
   logger = logging.getLogger(__name__)

   try:
       risky_operation()
   except SpecificError as e:
       logger.warning(f"Expected error: {e}")
       # Handle or continue
   except Exception as e:
       logger.error(f"Unexpected error: {e}", exc_info=True)
       raise  # Re-raise unless explicitly handled
   ```

2. **Target files** (10 violations):
   - `apps/integration_validator.py` (4 instances)
   - `scripts/load_embeddings_to_astradb.py` (1 instance)
   - `tests/conftest.py` (2 instances)
   - `tests/crawler/test_sec_edgar_provider_enhanced.py` (1 instance)
   - `tests/test_authenticity_audit.py` (1 instance)
   - `tests/test_mcp_normalizer.py` (1 instance)

3. **Add failure-path tests**:
   - For each fixed exception handler, add test asserting specific exception raised

**Acceptance Criteria**:
- ✅ All 10 silent exception violations remediated
- ✅ Each has accompanying failure-path test
- ✅ Errors logged with full context (exc_info=True)

---

#### **Phase 5: Parquet Migration** (6 hours, Days 13-15)

**Scope**: Replace to_json() with to_parquet() for data artifacts (16 violations)

**Implementation**:

1. **Update `agents/scoring/rubric_models.py`** (production file):
   ```python
   # Add new method
   def to_parquet(self, output_path: Path) -> None:
       """Save rubric to Parquet format (SCA compliant)."""
       import pandas as pd
       df = pd.DataFrame([self.model_dump()])
       df.to_parquet(output_path, engine='pyarrow', compression='snappy')

   # Deprecate old method
   def to_json(self, output_path: Path) -> None:
       """DEPRECATED: Use to_parquet() for data artifacts."""
       import warnings
       warnings.warn("to_json() deprecated, use to_parquet()", DeprecationWarning)
       self.to_parquet(output_path.with_suffix('.parquet'))
   ```

2. **Document exemptions** in `.sca/exemptions.json`:
   - Test files: to_json() allowed for human-readable test fixtures
   - 3 violations in `tests/scoring/test_rubric_*.py`

**Acceptance Criteria**:
- ✅ Production code uses to_parquet()
- ✅ Test exemptions documented in `.sca/exemptions.json`
- ✅ Audit tool respects exemptions

---

#### **Phase 6: Task 018 Coverage Fix** (3 hours, Days 16-17)

**Scope**: Fix Task 018-esg-query-synthesis branch coverage gap (94.4% → ≥95%)

**Implementation**:

1. **Run coverage report**:
   ```bash
   pytest tasks/018-esg-query-synthesis -vv --cov --cov-branch --cov-report=term-missing
   ```

2. **Identify missing branches** (likely 2-3 uncovered conditionals)

3. **Add targeted tests** for missing branches

4. **Re-run validation**:
   ```bash
   bash "C:\projects\Work Projects\sca-protocol-skill\commands\validate-only.sh"
   ```

**Acceptance Criteria**:
- ✅ Branch coverage ≥95%
- ✅ validate-only.ps1 returns status: "ok"

---

## 3. Verification & Testing

### 3.1 Unit Tests (TDD Guard Compliance)

Each CP module must have:
- ≥1 test marked `@pytest.mark.cp`
- ≥1 Hypothesis property test
- ≥1 failure-path test

**Example: libs/utils/clock.py tests**:
```python
# tests/utils/test_clock.py
import pytest
from hypothesis import given, strategies as st
from libs.utils.clock import Clock, get_clock, set_clock

@pytest.mark.cp
def test_clock_fixed_time():
    """Test Clock with fixed time returns expected value."""
    clock = Clock(fixed_time=1609459200.0)
    assert clock.time() == 1609459200.0
    assert clock.now().year == 2021

@given(st.floats(min_value=0, max_value=2**31-1))
def test_clock_deterministic(fixed_time):
    """Property test: Clock is idempotent with fixed time."""
    clock = Clock(fixed_time=fixed_time)
    assert clock.time() == clock.time()
    assert clock.now() == clock.now()

def test_clock_invalid_time_raises():
    """Failure-path test: Clock raises ValueError on negative time."""
    with pytest.raises(ValueError, match="non-negative"):
        Clock(fixed_time=-1.0)

def test_clock_real_time():
    """Test Clock without fixed time uses real clock."""
    import time
    clock = Clock()
    before = time.time()
    clock_time = clock.time()
    after = time.time()
    assert before <= clock_time <= after
```

### 3.2 Integration Tests

**Determinism Test** (`tests/integration/test_determinism.py`):
```python
@pytest.mark.integration
def test_full_workflow_deterministic():
    """Integration test: Same seed produces identical results."""
    import hashlib

    results = []
    for _ in range(10):
        # Run with SEED=42, FIXED_TIME=1609459200
        output = run_esg_query_workflow(seed=42, fixed_time=1609459200)
        hash_val = hashlib.sha256(str(output).encode()).hexdigest()
        results.append(hash_val)

    # All hashes should be identical
    assert len(set(results)) == 1, "Workflow is non-deterministic!"
```

**Network Isolation Test** (`tests/integration/test_network_isolation.py`):
```python
@pytest.mark.integration
def test_no_live_network_calls():
    """Integration test: Test suite makes zero live HTTP calls."""
    import pytest_socket
    pytest_socket.disable_socket()  # Block all network

    # Run test suite (should pass if all using MockHTTPClient)
    result = pytest.main(["-x", "tests/"])
    assert result == 0, "Tests failed with network disabled!"
```

### 3.3 Differential Testing

**Clock Differential Test**:
```python
def test_clock_differential():
    """Differential test: Outputs differ only in timestamps."""
    # Run with FIXED_TIME
    output_fixed = run_workflow(fixed_time=1609459200)

    # Run with real clock
    output_real = run_workflow(fixed_time=None)

    # Strip timestamps
    output_fixed_stripped = {k: v for k, v in output_fixed.items() if 'time' not in k}
    output_real_stripped = {k: v for k, v in output_real.items() if 'time' not in k}

    # Logic should be identical
    assert output_fixed_stripped == output_real_stripped
```

---

## 4. Success Criteria & Acceptance

### 4.1 Phase-by-Phase Gates

| Phase | Gate Condition | Validation Command |
|-------|----------------|-------------------|
| 1 | 0 FATAL violations | `python scripts/qa/authenticity_audit.py` |
| 2 | 0 nondeterministic_time violations | `grep -r "datetime.now()" --include="*.py" agents/ apps/ libs/` |
| 3 | 0 network_import violations | `pytest --tb=short 2>&1 \| grep -i connection` |
| 4 | 0 silent_exception violations | AST scan in audit tool |
| 5 | 0 json_as_parquet violations (prod) | Audit + exemption check |
| 6 | Task 018 coverage ≥95% | `validate-only.ps1` |

### 4.2 Final Acceptance Criteria

**Status**: Task 019 complete when ALL of the following are true:

1. ✅ **Authenticity Audit**: status="ok", 0 FATAL, ≤5 WARN (all documented in exemptions.json)
2. ✅ **Determinism Test**: 10 runs with SEED=42 produce identical SHA256 hash
3. ✅ **Network Isolation**: Zero live HTTP calls in test suite
4. ✅ **Coverage**: ≥95% line & branch on CP files (libs/utils/*)
5. ✅ **TDD Compliance**: All CP files have @pytest.mark.cp + Hypothesis + failure tests
6. ✅ **Task 018**: Branch coverage ≥95%
7. ✅ **Validation Skill**: `validate-only.ps1` returns status: "ok"

---

## 5. Rollback & Risk Mitigation

### 5.1 Rollback Plan

**Per-Phase Rollback**:
- Git branch per phase: `phase-N-<description>`
- If phase fails validation, rollback: `git checkout main`
- Review `qa/run_log.txt` for failure root cause
- Apply targeted fix, retry phase

### 5.2 Risk Mitigation Strategies

| Risk | Mitigation |
|------|------------|
| Clock injection breaks tests | Gradual rollout (top 20 first), per-module validation |
| HTTP fixtures incomplete | Generate from live API (one-time capture), version control |
| Determinism fails on OS-specific code | Use platform-agnostic algorithms, document exemptions |
| Exemption registry becomes stale | Add expiry dates, automated CI check |
| Regressions in rollout | Comprehensive test suite, differential testing |

---

**End of design.md**
